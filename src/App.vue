<script setup lang="ts">
import { User } from "./types/User";
import { reactive } from "vue";
import TheHeader from "@/components/TheHeader.vue";
import EntryEditor from "@/components/EntryEditor.vue";
import EntryCard from "@/components/EntryCard.vue";
import Entry from "./types/Entry";

const user: User = reactive({
  id: 1,
  username: "alienat3d",
  settings: [],
});

// 8.7.0 Итак, мы создадим для этого реактивный массив entries с типом массив, содержащий "Entry". ↓
const entries: Entry[] = reactive([]);

// 6.1.1 Доступ к передаваемым событием данным из payload мы можем получить через спец. переменную "$event".
// * 7.0 На этом уроке займёмся рефакторингом и улучшим все случаи, где мы пока использовали в качестве типа именованный объект, чтобы определить запись "entry" журнала. А заодно мы сможем получить представление как TS может быть полезен в рефакторинге, помогая не забывать изменять при этом определённые элементы. Итак для этого создадим ещё один файл с interface.
// Go to [src\types\Entry.ts]
// 7.8 Здесь мы также заменим типизацию через объект на новый interface.
// 8.6 Нам также следует доделать функцию "handleCreateEntry", чтобы она не просто выводила данные в консоль, а вместо этого добавляли в реактивный массив, где будут находиться все записи. ↑
// 8.7.1 А с помощью метода push будем добавлять новые записи в него. Хотя это не совсем то, что нам нужно, т.к. метод "push" будет добавлять новые записи в самый конец массива, а следовательно в низ списка записей, а нам бы хотелось, чтобы новые записи, наоборот появлялись сверху. Потому здесь более подходящим методом будет "unshift", который будет добавлять новые записи в начало массива. ↓
// const handleCreateEntry = (entry: { text: string; emoji: Emoji | null }) => {
const handleCreateEntry = (entry: Entry) => {
  entries.unshift(entry);
};
</script>

<!-- ? 5.4 Когда мы начнём писать Vue-директиву "v-on" (сокр. @), то увидим целый длинный список разнообразных событий. Среди них также появился наш новый "create". Однако, если мы попытаемся найти "create" на другом компоненте, то увидим, что автозаполнение не работает, т.к. мы его там не регистрировали. -->
<!-- Go to [src\components\EntryEditor.vue] -->
<!-- 6.1.0 Наступило время применить кастомное событие "@create" здесь. Мы будем слушать это событие, т.е. сигнал, отправляемый дочерним комп. родительскому по событию submit, при сохранении формы, и тогда будет вызываться функция "handleCreateEntry". ↑ -->
<!-- 8.8 Затем мы будем циклом распечатывать все находящиеся в реактивном массиве "entries" записи. Не забываем про "key" атрибут, необходимый для учёта Vue уникальных элементов списка, чтобы не перепутывался их порядок. -->
<template>
  <main class="container m-auto p-10">
    <TheHeader />
    <EntryEditor @@create="handleCreateEntry" />
    <ul>
      <li v-for="entry in entries" :key="entry.id">
        <EntryCard />
      </li>
    </ul>
  </main>
</template>
